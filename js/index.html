    <html>
    <head>
    </head>
    <body>
    <h1> Websocket test </h1>

    <script src="flatbuffers.js"></script>
    <script src="thymio_generated.js"></script>
    <script type="text/javascript">
    /* Wrap a promise to allow external resolve */
    class Request extends Promise {
        constructor(promise) {
            super(promise)
        }

        get node_id() {
            return this._node_id
        }

        _trigger_error(err) {
            this._onerror(err)
        }

        _trigger_then(...args) {
           return this._then.apply(this, args);
        }

        static create(request_id, node_id) {
            var then    = undefined;
            var onerror = undefined;
            let p = new Request(function(resolve, reject){
                then    = resolve;
                onerror = reject;
            }.bind(this));
            p._then = then
            p._onerror = onerror
            p._request_id = request_id
            p._node_id = node_id
            return p
        }
    }
    Request.ErrorType = mobsya.fb.ErrorType;

    class AsebaVMDescription {
        constructor() {
            this.bytecode_size = this.data_size = this.stack_size = 0;
            this.variables = []
            this.functions = []
            this.events    = []
        }
    }


    class Node {
        constructor(client, id, status) {
            this._id = id;
            this._status = status;
            this._desc   = undefined;
            this._client = client
        }
        get id() {
            return this._id
        }

        get status() {
            return this._status
        }

        get disconnected() {
            return this._status == mobsya.fb.NodeStatus.disconnected
        }

        get status_str() {
            switch(this.status) {
                case mobsya.fb.NodeStatus.connected: return "connected"
                case mobsya.fb.NodeStatus.ready: return "ready"
                case mobsya.fb.NodeStatus.busy: return "busy"
                case mobsya.fb.NodeStatus.disconnected: return "disconnected"
            }
            return "unknow"
        }

        async lock() {
            return await client.lock_node(this._id)
        }

        async unlock() {
            return await client.unlock_node(this._id)
        }

        async get_description() {
            if(!this._desc)
                this._desc = await client.request_aseba_vm_description(this._id);
            return this._desc
        }

        async send_aseba_code(code) {
            return await client.send_aseba_code(this._id, code);
        }

        _set_status(status) {
            if(status != this._status) {
                this._status = status
                if(this.on_status_changed) {
                    this.on_status_changed(status)
                }
            }
        }
    }
    Node.Status = mobsya.fb.NodeStatus;

    class MobsyaClient {

        constructor(url) {
            this._socket = new WebSocket(url)
            this._socket.binaryType = 'arraybuffer';
            this._socket.onopen = this.onopen.bind(this)
            this._socket.onmessage = this.onmessage.bind(this)

            //In progress requests (id : node)
            this._requests = new Map();
            //Known nodes (id : node)
            this._nodes    = new Map();
        }

        onopen(event) {
            console.log("connected")
        }

        on_nodes_changed(nodes) {
            console.log("unimplemented")
        }

        onmessage (event) {
            let data = new Uint8Array(event.data)
            let buf  = new flatbuffers.ByteBuffer(data);

            let message = mobsya.fb.Message.getRootAsMessage(buf, null)
            switch(message.messageType()) {
                case mobsya.fb.AnyMessage.NodesChanged: {
                    this.on_nodes_changed(this._nodes_changed_as_node_list(message.message(new mobsya.fb.NodesChanged())))
                    break;
                }
                case mobsya.fb.AnyMessage.NodeAsebaVMDescription: {
                    let msg = message.message(new mobsya.fb.NodeAsebaVMDescription())
                    let req = this._get_request(msg.requestId())
                    const id = msg.nodeId()
                    if(req) {
                        req._trigger_then(id, this._unserialize_aseba_vm_description(msg))
                    }
                    break;
                }
                case mobsya.fb.AnyMessage.RequestCompleted: {
                    let msg = message.message(new mobsya.fb.RequestCompleted())
                    let req = this._get_request(msg.requestId())
                    if(req) {
                        req._trigger_then()
                    }
                    break;
                }
                case mobsya.fb.AnyMessage.Error: {
                    let msg = message.message(new mobsya.fb.Error())
                    let req = this._get_request(msg.requestId())
                    if(req) {
                        req._trigger_error(msg.error())
                    }
                    break
                }
            }
        }

        /* request the description of the aseba vm for the node with the given id */
        request_aseba_vm_description(id) {
            let builder = new flatbuffers.Builder();
            let req_id  = this._gen_request_id()

            mobsya.fb.RequestNodeAsebaVMDescription.startRequestNodeAsebaVMDescription(builder)
            mobsya.fb.RequestNodeAsebaVMDescription.addRequestId(builder, req_id)
            mobsya.fb.RequestNodeAsebaVMDescription.addNodeId(builder, id)
            const offset = mobsya.fb.RequestNodeAsebaVMDescription.endRequestNodeAsebaVMDescription(builder)
            this._wrap_message_and_send(builder, offset, mobsya.fb.AnyMessage.RequestNodeAsebaVMDescription)
            return this._prepare_request(req_id, id)
        }

        /* request the description of the aseba vm for the node with the given id */
        lock_node(id) {
            let builder = new flatbuffers.Builder();
            let req_id  = this._gen_request_id()

            mobsya.fb.LockNode.startLockNode(builder)
            mobsya.fb.LockNode.addRequestId(builder, req_id)
            mobsya.fb.LockNode.addNodeId(builder, id)
            let offset = mobsya.fb.LockNode.endLockNode(builder)
            this._wrap_message_and_send(builder, offset, mobsya.fb.AnyMessage.LockNode)
            return this._prepare_request(req_id, id)
        }

        unlock_node(id) {
            let builder = new flatbuffers.Builder();
            let req_id  = this._gen_request_id()

            mobsya.fb.UnlockNode.startUnlockNode(builder)
            mobsya.fb.UnlockNode.addRequestId(builder, req_id)
            mobsya.fb.UnlockNode.addNodeId(builder, id)
            let offset = mobsya.fb.UnlockNode.endUnlockNode(builder)
            this._wrap_message_and_send(builder, offset, mobsya.fb.AnyMessage.UnlockNode)
            return this._prepare_request(req_id, id)
        }

        _nodes_changed_as_node_list(msg) {
            let nodes = []
            for(let i = 0; i < msg.nodesLength(); i++) {
                const n = msg.nodes(i);
                let node = this._requests.get(id)
                if(!node) {
                    node = new Node(this, n.nodeId(), n.status())
                    this._requests.set(n.nodeId(), node)
                }
                if(n.status() == Node.Status.disconnected) {
                    this._requests.delete(n.nodeId())
                }
                node._set_status(n.status())
            }
            return nodes
        }

        _unserialize_aseba_vm_description(msg) {
            let desc = new AsebaVMDescription()
            desc.bytecode_size = msg.bytecodeSize()
            desc.data_size  = msg.dataSize()
            desc.stack_size = msg.stackSize()

            for(let i = 0; i < msg.variablesLength(); i++) {
                const v = msg.variables(i);
                desc.variables.push({"name" : v.name(), "size" : v.size()})
            }

            for(let i = 0; i < msg.eventsLength(); i++) {
                const v = msg.events(i);
                desc.events.push({"name" : v.name(), "description" : v.description()})
            }

            for(let i = 0; i < msg.functionsLength(); i++) {
                const v = msg.functions(i);
                let params = []
                for(let j = 0; j < v.parametersLength(); j++) {
                    const p = v.parameters(i);
                    params.push({"name" : v.name(), "size" : p.size()})
                }
                desc.functions.push({"name" : v.name(), "description" : v.description(), "params": params})
            }
            return desc
        }

        _wrap_message_and_send(builder, offset, type) {
            mobsya.fb.Message.startMessage(builder)
            mobsya.fb.Message.addMessageType(builder, type)
            mobsya.fb.Message.addMessage(builder, offset)
            const builtMsg = mobsya.fb.Message.endMessage(builder)
            builder.finish(builtMsg);
            this._socket.send(builder.asUint8Array())
        }

        _gen_request_id(min, max) {
            let n = 0
            do {
                n = Math.floor(Math.random() * (0xffffffff - 2)) + 1
            }while(this._requests.has(n))
            return n
        }

        _get_request(id) {
            const req = this._requests.get(id)
            if(req != undefined)
                this._requests.delete(id)
             console.log(id, req)
             if(req == undefined) {
                console.error(`unknown request ${id}`)
            }
            return req
        }
        _prepare_request(req_id, node_id) {
            let req = Request.create(req_id, node_id)
            this._requests.set(req_id, req)
            return req
        }
    }

    class TestClient extends MobsyaClient {
        constructor(url) {
            super(url);
        }


    }

    let client = new MobsyaClient("ws://localhost:8597");
    let selectedNode = undefined
    client.on_nodes_changed = function(nodes) {
        console.log(nodes)
        for (let node of nodes) {
            console.log(`${node.id} : ${node.status_str}`)
            if((!selectedNode || selectedNode.disconnected) && node.status == Node.Status.ready) {
                selectedNode = node
                console.log(`Locking ${node.id}`)
                selectedNode.lock().then( () =>  {
                    console.log("Node locked")
                    console.log(node)
                }).catch((err) =>  {
                    switch(err) {
                        case Request.ErrorType.node_busy:
                            console.log("Node Busy !")
                            break
                        default:
                            console.log("unknown error")
                    }
                })
                break;
            }
        }
    }

    </script>

    </body>
    </html>
